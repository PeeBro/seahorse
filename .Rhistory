input_folder <- params$input_folder
# Create output folder
output_folder <- sprintf("%s_OUTPUT", input_folder)
o_path <- here("Data", "OUTPUT", output_folder)
if(!dir.exists(o_path)){
dir.create(path = o_path)
}
# source the functions used in analysis
source(here("R", "src", "analysis_source_functions_FOUR_INTERVALS.R"))
# INPUT_PATH  <- (here('/Data/INPUT/ConBIS')) # path to the folder of interest
INPUT_PATH  <- (here('Data', "INPUT", input_folder)) # path to the folder of interest
# OUTPUT_PATH <- (here('/Data/OUTPUT/HF'))
OUTPUT_PATH <- (here('Data', "OUTPUT", output_folder))
# Delete old knit files
knit_cache <- here('Experiments', "OCR+ECAR-Pipeline_cache")
knit_files <- here("Data", "OUTPUT", output_folder, "OCR+ECAR-Pipeline_files")
knit_folders <- c(knit_cache, knit_files)
for (folder in knit_folders) {
if (file.exists(folder))
unlink(folder, recursive = T)
}
# Initialize the knitting process
# rmarkdown::render(here('Experiments', "OCR+ECAR-Pipeline.Rmd"), output_dir = OUTPUT_PATH)
# Read The the separate xlsx files from folder, Specify entire path to folder.
data <- read_xlsx_set(INPUT_PATH, ".xlsx")
dm <- data$rates
# perep for OCR interval 5 not used
d_OCR  <- dm %>% filter(Interval != "Int5")
# filter out samples with any of intervals having less than 8 measurements
sumar <- d_OCR %>%
group_by(sample_id, Interval) %>%
summarise(n = n()) %>%
filter(n < 18) # les then 18 so it corespods to at least 6 different wells
# number of intervals has to be 4 or discarted
inter <- d_OCR %>%
group_by(sample_id) %>%
summarise(n_inter = length(unique(Interval))) %>%
filter(n_inter != 4)
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(sumar$sample_id))
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(inter$sample_id))
paste0("Samples removed due lack of usable measurements(less than 8  in any interval)")
unique(sumar$sample_id)
paste0("Samples removed because there are no 4 intervals )")
unique(inter$sample_id)
# Identify Outliars
# DT = loaded dataframe
# cut.well = threshold for well outliaer,
# cut.point = threshold for point outliaer
# x = Variable: "LOCR", "OCR
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
# clean enviroment
rm(d_OCR)
# write the data into file
write_csv(dr_ocr, paste0(OUTPUT_PATH,"/Data_removed_OCR.csv"))
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
# perep for OCR interval 5 not used
d_OCR  <- dm %>% filter(Interval != "Int5")
# filter out samples with any of intervals having less than 8 measurements
sumar <- d_OCR %>%
group_by(sample_id, Interval) %>%
summarise(n = n()) %>%
filter(n < 18) # les then 18 so it corespods to at least 6 different wells
# number of intervals has to be 4 or discarted
inter <- d_OCR %>%
group_by(sample_id) %>%
summarise(n_inter = length(unique(Interval))) %>%
filter(n_inter != 4)
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(sumar$sample_id))
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(inter$sample_id))
paste0("Samples removed due lack of usable measurements(less than 8  in any interval)")
unique(sumar$sample_id)
paste0("Samples removed because there are no 4 intervals )")
unique(inter$sample_id)
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
View(dm)
# Set path and load the package "here"
here::i_am("Experiments/OCR+ECAR-Pipeline.Rmd")
if(!("here" %in% installed.packages()[, "Package"])) {
install.packages("here")
}
library(here)       # Used to set the path to the package dir. on the machine
# Check if all packages are installed
source(here("R", "src", "config_file.R"))
# Load libraries
library(tools)
library(reshape2)
library(reshape)
library(tidyverse)
library(readxl)     # Read xlsx file
library(knitr)      # Used for tables
library(kableExtra)
library(shiny)
# Get input folder
input_folder <- params$input_folder
# Create output folder
output_folder <- sprintf("%s_OUTPUT", input_folder)
o_path <- here("Data", "OUTPUT", output_folder)
if(!dir.exists(o_path)){
dir.create(path = o_path)
}
# source the functions used in analysis
source(here("R", "src", "analysis_source_functions_FOUR_INTERVALS.R"))
# INPUT_PATH  <- (here('/Data/INPUT/ConBIS')) # path to the folder of interest
INPUT_PATH  <- (here('Data', "INPUT", input_folder)) # path to the folder of interest
# OUTPUT_PATH <- (here('/Data/OUTPUT/HF'))
OUTPUT_PATH <- (here('Data', "OUTPUT", output_folder))
# Delete old knit files
knit_cache <- here('Experiments', "OCR+ECAR-Pipeline_cache")
knit_files <- here("Data", "OUTPUT", output_folder, "OCR+ECAR-Pipeline_files")
knit_folders <- c(knit_cache, knit_files)
for (folder in knit_folders) {
if (file.exists(folder))
unlink(folder, recursive = T)
}
# Initialize the knitting process
# rmarkdown::render(here('Experiments', "OCR+ECAR-Pipeline.Rmd"), output_dir = OUTPUT_PATH)
# Read The the separate xlsx files from folder, Specify entire path to folder.
data <- read_xlsx_set(INPUT_PATH, ".xlsx")
dm <- data$rates
# perep for OCR interval 5 not used
d_OCR  <- dm %>% filter(Interval != "Int5")
# filter out samples with any of intervals having less than 8 measurements
sumar <- d_OCR %>%
group_by(sample_id, Interval) %>%
summarise(n = n()) %>%
filter(n < 18) # les then 18 so it corespods to at least 6 different wells
# number of intervals has to be 4 or discarted
inter <- d_OCR %>%
group_by(sample_id) %>%
summarise(n_inter = length(unique(Interval))) %>%
filter(n_inter != 4)
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(sumar$sample_id))
d_OCR <- d_OCR %>%
filter(! sample_id %in% unique(inter$sample_id))
paste0("Samples removed due lack of usable measurements(less than 8  in any interval)")
unique(sumar$sample_id)
paste0("Samples removed because there are no 4 intervals )")
unique(inter$sample_id)
# Identify Outliars
# DT = loaded dataframe
# cut.well = threshold for well outliaer,
# cut.point = threshold for point outliaer
# x = Variable: "LOCR", "OCR
dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
# clean enviroment
rm(d_OCR)
# write the data into file
write_csv(dr_ocr, paste0(OUTPUT_PATH,"/Data_removed_OCR.csv"))
# amount of removed outliars
dr_ocr %>%
group_by(sample_id, is.out.p) %>%
summarise(n = n()) %>%
group_by(sample_id) %>%
mutate(size = sum(n),
ptg = n / size *100,
percentage = paste(format(ptg, digits= 1, nsmall=2),"%")) %>%
filter(is.out.p == T) %>%
arrange(desc(ptg)) %>%
select(sample_id, percentage) %>%
kable(caption="Amount of removed outliers across samples") %>%
kable_styling(full_width = F)
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
xlab("Interval")+
ylim(0,300)
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
xlab("Interval")+
ylim(0,50)
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(fill=guide_legend(title="Outlier"))+
xlab("Interval")+
ylim(0,50)+
ylab("OCR (Normalized)")
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(color=guide_legend(title="Outlier"))+
xlab("Interval")+
ylim(0,20)+
ylab("OCR (Normalized)")+
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(color=guide_legend(title="Outlier"))+
xlab("Interval")+
ylim(0,20)+
ylab("OCR (Normalized)")
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(color=guide_legend(title="Outlier"))+
xlab("Interval")+
ylim(0,15)+
ylab("OCR (Normalized)")
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(color=guide_legend(title="Outlier"))+
xlab("Measurement")+
ylim(0,15)+
ylab("OCR (Normalized)")
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
norm.be <- compute_bioenergetics_(dr_ocr, "OCR")
log.be  <- compute_bioenergetics_(dr_ocr, "LOCR")
write_csv(norm.be$estimates, paste0(OUTPUT_PATH,"/OCR-Estimated_values.csv"))
write_csv(log.be$estimates, paste0(OUTPUT_PATH,"/LOCR-Estimates_values.csv"))
write_csv(norm.be$bioenergetics, paste0(OUTPUT_PATH,"/OCR-BE-table.csv"))
write_csv(log.be$bioenergetics, paste0(OUTPUT_PATH,"/LOCR-BE-table.csv"))
# Print interval estimates
norm.be$estimates[1:4,] %>%
kable(digits = 3, caption = "Example of estimates file ") %>%
kable_styling(full_width = F)
# norm estimates boxplots
ggplot(norm.be$estimates)+
ggtitle("OCR Estimates natural scale")+
geom_boxplot(aes(Interval,mean), width = 0.6, outlier.size = -1, show.legend = FALSE, fill = "pink")+
geom_jitter(aes(Interval,mean), width = 0.2, show.legend = FALSE, size = 0.5 )+
xlab("Intervals")+
ylab("logOCR")+
theme_bw()
# log estimates boxplots
ggplot(log.be$estimates)+
ggtitle("logOCR Estimates")+
geom_boxplot(aes(Interval,mean), width = 0.6, outlier.size = -1, show.legend = FALSE, fill = "pink")+
geom_jitter(aes(Interval,mean), width = 0.2, show.legend = FALSE, size = 0.5 )+
xlab("Intervals")+
ylab("logOCR")+
theme_bw()
# ADD coefficients of variation
# normal scale Bioenergetics
n.bio <- melt(norm.be$bioenergetics)
n.bio %>%
filter(variable != "Other") %>%
ggplot(aes(variable, value, fill = variable ))+
ggtitle("Difference based natural scale Bio-Energetics OCR")+
geom_boxplot(width = 0.5, outlier.size = -1, alpha = 0.7)+
geom_jitter(width = 0.1, show.legend = FALSE, size = 0.5 )+
xlab("Bio-Energetics")+
ylab(" ")+
theme_bw()
# log scale Bioenergetics
l.bio   <- melt(log.be$bioenergetics )
l.bio %>%
filter(variable != "Other") %>%
ggplot(aes(variable, value, fill = variable))+
ggtitle("Ratio based log scale Bio-Energetics OCR (folds)")+
geom_boxplot( width = 0.5, outlier.size = -1, alpha = 0.7)+
geom_jitter( width = 0.1, show.legend = FALSE, size = 0.5 )+
xlab(" Log Bio-Energetics")+
ylab(" ")+
theme_bw()
# write difference based bioenergetics
# uncomment and export be.er if you want to get standard errors of bioenergetics
# st.err <- melt(norm.be$standard.errors, value.name = "SE", variable.name = "Bio.e" )
# be.er  <- left_join(n.bio, st.err, by = c("Sample", "variable"))
# be.er  <- arrange(be.er, Sample)
write_csv(n.bio, paste0(OUTPUT_PATH,"/OCR-BioEnergetics.csv"))
# write ratio based bienergetics
# # uncomment and export be.er if you want to get standard errors of bioenergetics
# st.err <- melt(log.be$standard.errors, value.name = "SE", variable.name = "variable" )
# be.er  <- left_join(l.bio, st.err, by = c("Sample", "variable"))
# be.er <- arrange(be.er, Sample)
write_csv(l.bio, paste0(OUTPUT_PATH,"/LogOCR-BioEnergetics.csv"))
# Print interval estimates
l.bio[1:4,] %>%
kable(digits = 3, caption = "Example of Bioenergetics file ") %>%
kable_styling(full_width = F)
# difference based BE
n.bio %>%
mutate(Group = ifelse(grepl("A", Sample), "A", "B")) %>% # change "A" and "B" for any character or string
ggplot(aes(Group, value, fill = variable))+
ggtitle("OCR Normal scale Bio-Energetics biological groups ")+
geom_boxplot(width = 0.5, outlier.size = -1, alpha = 0.7)+
geom_jitter(width = 0.1, show.legend = FALSE, size = 0.5)+
xlab("Bio-Energetics")+
ylab("OCR")+
facet_grid(. ~ variable ) +
theme_bw()
# ratio based BE
l.bio %>%
mutate(Group = ifelse(grepl("A", Sample), "A", "B")) %>% # change "A" and "B" for any character or string
ggplot(aes(Group, value, fill = variable))+
ggtitle("OCR Normal scale Bio-Energetics biological groups ")+
geom_boxplot(width = 0.5, outlier.size = -1, alpha = 0.7)+
geom_jitter(width = 0.1, show.legend = FALSE, size = 0.5)+
xlab("Bio-Energetics")+
ylab("OCR")+
facet_grid(. ~ variable ) +
theme_bw()
# perep for OCR interval 5 not used
d_ECAR <- dm %>% filter(!Interval %in% c("Int4","Int3") & Measurement != 7 )# & Protocol == "Glyco")
# filter out samples with any of intervals having less than 8 measurements
sumar <- d_ECAR %>%
group_by(sample_id, Interval) %>%
summarise(n = n()) %>%
filter(n < 8 | Interval == "Int1" & n < 18 | Interval == "Int2" & n < 18 |Interval == "Int5" & n < 12 )
# number of intervals has to be 3 or discarted
inter <- d_ECAR %>%
group_by(sample_id) %>%
summarise(n_inter = length(unique(Interval))) %>%
filter(n_inter != 3)
d_ECAR <- d_ECAR %>%
filter(! sample_id %in% unique(sumar$sample_id)) %>%
filter(! sample_id %in% unique(inter$sample_id))
paste0("Samples removed due lack of usable measurements(less than 8  in any interval)")
unique(sumar$sample_id)
paste0("Samples removed because don't have 3 Intervals")
unique(inter$sample_id)
# Identify Outliars
# DT = loaded dataframe
# cut.well = threshold for well outliaer,
# cut.point = threshold for point outliaer
# x = Variable: "LOCR" or "OCR" or "ECAR"
dr_ecar <- idfy_sinleP_outlier(DT = d_ECAR, cut.point = 5, x = "ECAR" )  # could Print arguments
# write the data into file
write_csv(dr_ecar, paste0(OUTPUT_PATH,"/Data_removed_ECAR.csv"))
# perep for OCR interval 5 not used
d_ECAR <- dm %>% filter(!Interval %in% c("Int4","Int3") & Measurement != 7 )# & Protocol == "Glyco")
# filter out samples with any of intervals having less than 8 measurements
sumar <- d_ECAR %>%
group_by(sample_id, Interval) %>%
summarise(n = n()) %>%
filter(n < 8 | Interval == "Int1" & n < 18 | Interval == "Int2" & n < 18 |Interval == "Int5" & n < 12 )
# number of intervals has to be 3 or discarted
inter <- d_ECAR %>%
group_by(sample_id) %>%
summarise(n_inter = length(unique(Interval))) %>%
filter(n_inter != 3)
d_ECAR <- d_ECAR %>%
filter(! sample_id %in% unique(sumar$sample_id)) %>%
filter(! sample_id %in% unique(inter$sample_id))
paste0("Samples removed due lack of usable measurements(less than 8  in any interval)")
unique(sumar$sample_id)
paste0("Samples removed because don't have 3 Intervals")
unique(inter$sample_id)
# amount of removed outliars
dr_ocr %>%
group_by(sample_id, is.out.p) %>%
summarise(n = n()) %>%
group_by(sample_id) %>%
mutate(size = sum(n),
ptg = n / size *100,
percentage = paste(format(ptg, digits= 1, nsmall=2),"%")) %>%
filter(is.out.p == T) %>%
arrange(desc(ptg)) %>%
select(sample_id, percentage) %>%
kable(caption="Amount of removed outliers across samples") %>%
kable_styling(full_width = F)
for (smpl in unique(dr_ocr$sample_id)) {
d    <- filter(dr_ocr, sample_id == smpl)
ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
plot <- ggplot(d, aes(Time, OCR))+
ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
geom_line(aes(group = Well, linetype = Protocol),size = 0.2, color = "grey") +
geom_point(aes(Time, OCR, color = is.out.p))+
guides(color=guide_legend(title="Outlier"))+
xlab("Measurement")+
ylim(0,15)+
ylab("OCR (Normalized)")
print(plot +theme_bw())
}
# Violin plot LOCR
#  for (smpl in unique(dr_ocr$sample_id)) {
#    d    <- filter(dr_ocr, sample_id == smpl)
#    ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
#    plot <- ggplot(d, aes(Time, LOCR))+
#              ggtitle(paste0("ID: ", smpl, "  out: ", format(ptg, digits = 3), "%"))+
#              geom_violin(aes(Interval, LOCR))+
#              geom_point(aes(Interval, LOCR, color = is.out.p))+
#              xlab("Interval")#+
#
#    print(plot +theme_bw())
# }
