---
title: "OCR+PER-Pipeline-FOUR-INTERVALS"
output: 
  html_document:
    number_sections: true
params:
  input_folder: "GtF_2021-2_FAKE"
editor_options: 
  chunk_output_type: console
---
<br>
<br>
<br>
<br>

# HOW TO USE

Step 1: Make a new folder in the Data/INPUT folder and place your excel files there <br>
Step 2: Make sure that you have not opened any of the files in the folder <br>
Step 3: Write the name of the folder above. Use quotes like this "My_folder" <br>
Step 4: Run the code chunk below <br>



```{r eval = FALSE, include=FALSE}
# Set path and load the package "here"

here::i_am("Experiments/OCR+PER-Pipeline.Rmd")

if(!("here" %in% installed.packages()[, "Package"])) {
  install.packages("here")
}
library(here)       # Used to set the path to the package dir. on the machine 



# Check if all packages are installed
source(here("R", "src", "config_file.R"))


# Load libraries
library(tools)
library(reshape2)
library(reshape)
library(tidyverse)
library(readxl)     # Read xlsx file
library(knitr)      # Used for tables 
library(kableExtra)
library(shiny)
library(ggbeeswarm)



# Get input folder
input_folder <- params$input_folder

# Create output folder

output_folder <- sprintf("%s_OUTPUT", input_folder)
o_path <- here("Data", "OUTPUT", output_folder)

if(!dir.exists(o_path)){
  dir.create(path = o_path)
}


# source the functions used in analysis
source(here("R", "src", "analysis_source_functions_FOUR_INTERVALS.R"))

# INPUT_PATH  <- (here('/Data/INPUT/ConBIS')) # path to the folder of interest
INPUT_PATH  <- (here('Data', "INPUT", input_folder)) # path to the folder of interest
# OUTPUT_PATH <- (here('/Data/OUTPUT/HF')) 
OUTPUT_PATH <- (here('Data', "OUTPUT", output_folder))


# Delete old knit files
name_of_cache <- list.files(path = "./Experiments", pattern = "cache", include.dirs = TRUE) # Finds the correct folder by it self. Deletes ALL cache folders.
knit_cache <- here('Experiments', name_of_cache)
knit_files <- here("Data", "OUTPUT", output_folder, "OCR+PER-Pipeline_files")
knit_figures <- here("Data", "OUTPUT", output_folder, "OCR+PER-Pipeline-FOUR-INTERVALS_files")
knit_folders <- c(knit_cache, knit_files, knit_figures)
for (folder in knit_folders) {
  if (file.exists(folder))
  unlink(folder, recursive = T)
}


# Initialize the knitting process
rmarkdown::render(here('Experiments', "OCR+PER-Pipeline-FOUR-INTERVALS.Rmd"), output_dir = OUTPUT_PATH)
```

# Overview of data
Steps performed: <br>
- Load data

```{r, message=TRUE, warning=FALSE, echo=FALSE, paged.print=FALSE}
# Read The the separate xlsx files from folder, Specify entire path to folder. 
source(here("R", "src", "analysis_source_functions_FOUR_INTERVALS.R"))
data <- read_xlsx_set(INPUT_PATH, ".xlsx")  
dm <- data$rates

```

# Wells excluded from the analysis
Steps performed: <br>
- Remove unassigned wells <br>
- Remove wells with OCR <= 10 in the first interval <br>
- Remove bad backgrounds for OCR and PER separately <br>
- Correct background for OCR and PER separately <br>
- Normalize wells based on cell count (OCR/1000 cells and PER/1000 cells) <br>
- Remove wells with no cell count measured <br>
- Remove wells where OCR and PER is 0 <br>
- Remove wells based on Hg measurements <br>

```{r echo=FALSE}
data$Hg_list %>%  
  kable(caption="Wells removed. Out of 140-160 mmHg interval") %>% 
  kable_styling()

```

```{r echo=FALSE}
data$OCR_background %>%  
  kable(caption="Background measurements not included in OCR correction") %>% 
  kable_styling()

```

```{r echo=FALSE}
data$PER_background %>%  
  kable(caption="Background measurements not included in PER correction") %>% 
  kable_styling()

```

```{r echo=FALSE}
data$Zero_measurements %>%  
  kable(caption="Empty measurements (OCR or PER = 0)") %>% 
  kable_styling()

```

```{r echo=FALSE}
data$No_cells_measured %>%  
  kable(caption="Wells with no cells measured") %>% 
  kable_styling()

```

```{r echo=FALSE}
data$Bad_Cells %>%  
  kable(caption="Wells with OCR < 10 in first interval") %>% 
  kable_styling()

```

<br>
<br>

# OCR 
## Filter out irrelevant samples 
Steps performed: <br>
- Check that the number of intervals for each sample is four and that no sample has an interval with less than 18 measurements <br>
```{r  echo=FALSE, message = FALSE}
d_OCR  <- dm

# filter out samples with an interval smaller than 18 measurements. Each interval consist of three or four measurements, so 18/3 = 6 wells should be present. (This approach should work because if individual measurements of wells are wrong (too high/low Hg) then the entire well is removed from the analysis. Thus we do only have "complete" wells with all measurements intact at this point.)
sumar <- d_OCR %>%
  group_by(sample_id, Interval) %>% 
  summarise(n = n()) %>% 
  filter(n < 18)

# number of intervals has to be 4 or the well discarted 
inter <- d_OCR %>% 
  group_by(sample_id) %>% 
  summarise(n_inter = length(unique(Interval))) %>% 
  filter(n_inter != 4)

d_OCR <- d_OCR %>% 
  filter(! sample_id %in% unique(sumar$sample_id))

d_OCR <- d_OCR %>% 
  filter(! sample_id %in% unique(inter$sample_id))

cat("Wells removed due lack of usable measurements (Less than six usable wells in any interval): ", paste(unique(sumar$sample_id), collapse = "\n"), sep = "\n")
cat("Wells removed because there are not four intervals: ", paste(unique(inter$sample_id), collapse = "\n"), sep = "\n")
```

## Identify Outliers
Steps performed: <br>
- Use an iterative process to remove outliers

Removed outliers in each iteration: <br>
```{r echo=FALSE}
# Identify Outliars
# DT = loaded dataframe
# cut.well = threshold for well outliaer,
# cut.point = threshold for point outliaer
# x = Variable: "LOCR", "OCR

dr_ocr <- idfy_sinleP_outlier(d_OCR, cut.point = 6, x = "LOCR")
# clean enviroment
rm(d_OCR)
# write the data into file
write_csv(dr_ocr, paste0(OUTPUT_PATH,"/Data_removed_OCR.csv"))
```

```{r echo=FALSE, warning=FALSE, echo=FALSE}
# amount of removed outliars
dr_ocr %>%
  group_by(sample_id, is.out.p) %>%
  summarise(n = n()) %>%
  group_by(sample_id) %>%
  mutate(size = sum(n),
         ptg = n / size *100,
         percentage = paste(format(ptg, digits= 1, nsmall=2),"%")) %>%
  filter(is.out.p == T) %>%
  arrange(desc(ptg)) %>%
  select(sample_id, percentage) %>%
  kable(caption="Amount of removed outliers across samples") %>%
  kable_styling(full_width = F)


```

## Print schemes of removed points for all samples
```{r echo=FALSE, echo=FALSE, cache = TRUE}

for (smpl in unique(dr_ocr$sample_id)) {
  d    <- filter(dr_ocr, sample_id == smpl)
  ptg  <- nrow(filter(d, is.out.p == T))/nrow(d)*100
  plot <- ggplot(d, aes(Time, OCR))+
            ggtitle(paste0("ID: ", smpl, " |  Outliers: ", format(ptg, digits = 3), "%"))+
            geom_line(aes(group = Well),size = 0.2, color = "grey") +
            geom_point(aes(Time, OCR, color = is.out.p))+
            guides(color=guide_legend(title="Outlier"))+
            xlab("Measurement")+
            # ylim(0,15)+
            ylab(expression("Mean OCR value [pmol O"[2]*" /1000 cells]"))

  print(plot +theme_bw())
}
```

## Summary statistics for each sample
```{r echo = FALSE}
ocr_summary_stats <- dr_ocr %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval, Group) %>% 
  summarise(well_mean = mean(OCR))%>% # Gives the mean value of each well withour outliers
  group_by(Group, Interval) %>% # Gives the mean value of each sample without outliers
  summarise(sample_mean = mean(well_mean),
            well_mean,
            Well)

locr_summary_stats <- dr_ocr %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval, Group) %>% 
  summarise(well_mean = mean(LOCR))%>% # Gives the mean value of each well withour outliers
  group_by(Group, Interval) %>% # Gives the mean value of each sample without outliers
  summarise(sample_mean = mean(well_mean),
            well_mean,
            Well)



ocr_summary_stats %>% ggplot(mapping = aes(x = Interval, y = well_mean, group = Group)) +
  geom_line(mapping = aes(x = Interval, y = sample_mean, group = Group), size = 0.2, color = "grey", position = position_dodge(width = 0.2) ) +
  geom_point(mapping = aes(x = Interval, y = sample_mean, fill = Group), color = "black", shape = 21, size = 3, position = position_dodge(width = 0.2) )+
  # stat_summary(fun = mean, geom = "crossbar", width = 0.1, aes(color = Group))+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.4, size = 0.5, aes(color = Group), position = position_dodge(width = 0.2) )+
  scale_fill_brewer(palette = "Dark2")+
  scale_color_brewer(palette = "Dark2")+
  ylab(expression("Mean OCR value [pmol O"[2]*" /1000 cells]"))+
  # geom_jitter(dr_ocr)
  theme_bw()+
  ggtitle("OCR estimates sample summary (Outliers removed)")

locr_summary_stats %>% ggplot(mapping = aes(x = Interval, y = well_mean, group = Group)) +
  geom_line(mapping = aes(x = Interval, y = sample_mean, group = Group), size = 0.2, color = "grey", position = position_dodge(width = 0.2) ) +
  geom_point(mapping = aes(x = Interval, y = sample_mean, fill = Group), color = "black", shape = 21, size = 3, position = position_dodge(width = 0.2) )+
  # stat_summary(fun = mean, geom = "crossbar", width = 0.1, aes(color = Group))+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.4, size = 0.5, aes(color = Group), position = position_dodge(width = 0.2) )+
  scale_fill_brewer(palette = "Dark2")+
  scale_color_brewer(palette = "Dark2")+
  ylab(expression("Mean LOCR value [log10(pmol O"[2]*" /1000 cells)]"))+
  # geom_jitter(dr_ocr)
  theme_bw()+
  ggtitle("LOCR estimates sample summary (Outliers removed)")

message("Figure description: Colored points are the group mean of wells, and the errorbars shows the sd of the well means for each group")

```





## Bioenergetics and Estimates
### Estimates
Estimates are taken by median of measurements from each interval in sample. Estimates are  stored together with other details about the intervals in files called <Method>-Estimated_values.csv in OUTPUT folder.

If you want to see or change how they are computed see the function compute_bioenergetics_ ()in file analysis_source_functions.R

```{r echo=FALSE}
norm.be <- compute_bioenergetics_(dr_ocr, "OCR")
log.be  <- compute_bioenergetics_(dr_ocr, "LOCR")

write_csv(norm.be$estimates, paste0(OUTPUT_PATH,"/OCR-Estimated_values.csv"))
write_csv(log.be$estimates, paste0(OUTPUT_PATH,"/LOCR-Estimates_values.csv"))
write_csv(norm.be$bioenergetics, paste0(OUTPUT_PATH,"/OCR-BE-table.csv"))
write_csv(log.be$bioenergetics, paste0(OUTPUT_PATH,"/LOCR-BE-table.csv"))

```

```{r echo=FALSE, echo=FALSE}
# Print interval estimates
norm.be$estimates[1:4,] %>%
  kable(digits = 3, caption = "Example of estimates file ") %>%
  kable_styling(full_width = F)
```

```{r echo = FALSE}
# We need a different bioenergetics calculation to make the plots. The values calculated above is for each sample in each interval. We also need data for each well

ocr_stats <- dr_ocr %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval) %>%
  summarise(well_mean = mean(OCR)) %>% 
  group_by(sample_id, Interval) %>%
  mutate(replicate_mean = mean(well_mean)) %>% ungroup %>%
  mutate(Date = substr(sample_id, start = nchar(sample_id)-15, stop = nchar(sample_id)),
         Group = substr(sample_id, start = 1, stop = nchar(sample_id)-19)) %>% 
  group_by(Group, Interval) %>%
  summarise(sample_mean = mean(well_mean),
            replicate_mean,
            well_mean,
            sample_id,
            Date)
  


locr_stats <- dr_ocr %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval) %>%
  summarise(well_mean = mean(LOCR)) %>% 
  group_by(sample_id, Interval) %>%
  mutate(replicate_mean = mean(well_mean)) %>% ungroup %>%
  mutate(Date = substr(sample_id, start = nchar(sample_id)-15, stop = nchar(sample_id)),
         Group = substr(sample_id, start = 1, stop = nchar(sample_id)-19)) %>% 
  group_by(Group, Interval) %>%
  summarise(sample_mean = mean(well_mean),
            replicate_mean,
            well_mean,
            sample_id,
            Date)

```



```{r, echo = FALSE,  fig.width = 8 , fig.height = 8 }
ocr_stats %>% ggplot(aes(x=Group, y=well_mean)) + 
  geom_beeswarm(aes(color = Date), cex=2, dodge.width = 0)+
  facet_wrap(~Interval, scales = "free")+
  ylab(expression("Mean OCR value [pmol O"[2]*" /1000 cells]"))+
  xlab("Sample")+
  stat_summary(fun = mean, geom = "crossbar", width = 0.3)+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.3)+
  geom_point(aes(x=Group, y = replicate_mean, fill = Date), color = "Black", size = 4, shape = 21)+
  theme_bw()+
  theme(legend.position="bottom",     
        strip.text.x = element_text(size = 12, face = "bold"),
        strip.text.y = element_text(size = 12, face = "bold"))+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("OCR estimates shown by well, replicate and sample")

locr_stats %>% ggplot(aes(x=Group, y=well_mean)) + 
  geom_beeswarm(aes(color = Date), cex=2, dodge.width = 0)+
  facet_wrap(~Interval, scales = "free")+
  ylab(expression("Mean Log(OCR) value [log10(pmol O"[2]*" /1000 cells)]"))+
  xlab("Sample")+
  stat_summary(fun = mean, geom = "crossbar", width = 0.3)+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.3)+
  geom_point(aes(x=Group, y = replicate_mean, fill = Date), color = "Black", size = 4, shape = 21)+
  theme_bw()+
  theme(legend.position="bottom",     
        strip.text.x = element_text(size = 12, face = "bold"),
        strip.text.y = element_text(size = 12, face = "bold"))+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("LOCR estimates shown by well, replicate and sample")

message("Figure description: Colors indicate replicates, large points represent the group mean of wells, the bold black line is the sample mean of wells, and the errorbars shows the sd of the well means for each group")
```





### Bioenergetics
Bioenergetics are computed from estimates, there there are two sets of bioenergetics provided.

  1. Ratio Based, computed from log(OCR) estimates Located in OUTPUT/LogOCR-BioEnergetics.csv

  2. Difference based, computed from OCR esimates Located in OUTPUT/OCR-BioEnergetics.csv
If you want to see or change how they are computed see the function compute_bioenergetics_() in file analysis_source_functions.R

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.width=10}
# ADD coefficients of variation
# normal scale Bioenergetics

n.bio <- melt(norm.be$bioenergetics)
n.bio <- n.bio %>%  mutate(Date = substr(Sample, start = nchar(Sample)-15, stop = nchar(Sample)),
                           Group = substr(Sample, start = 1, stop = nchar(Sample)-19))

n.bio %>%
  filter(variable != "Other") %>%
  ggplot(aes(x = variable, y = value))+
  ggtitle("Difference based natural scale Bio-Energetics OCR")+
  # geom_boxplot(width = 0.5, outlier.size = -1, alpha = 0.7)+
  geom_point(aes(fill = Group, shape = Date), size = 3, position = position_dodge(width = 0.2))+
  scale_shape_manual(values= c(21,22))+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  guides(fill=guide_legend(override.aes=list(shape=21)))+
  xlab("Bio-Energetics")+
  ylab(" ")+
  theme_bw()


# log scale Bioenergetics
l.bio   <- melt(log.be$bioenergetics )
l.bio <- l.bio %>%  mutate(Date = substr(Sample, start = nchar(Sample)-15, stop = nchar(Sample)),
                           Group = substr(Sample, start = 1, stop = nchar(Sample)-19))

l.bio %>%
  filter(variable != "Other") %>%
  ggplot(aes(variable, value, fill = variable))+
  ggtitle("Ratio based log scale Bio-Energetics OCR (folds)")+
  geom_point(aes(fill = Group, shape = Date), size = 3, position = position_dodge(width = 0.2))+
  scale_shape_manual(values= c(21,22))+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  guides(fill=guide_legend(override.aes=list(shape=21)))+
  xlab(" Log Bio-Energetics")+
  ylab(" ")+
  theme_bw()




```

```{r echo=FALSE}
# write difference based bioenergetics
# uncomment and export be.er if you want to get standard errors of bioenergetics
# st.err <- melt(norm.be$standard.errors, value.name = "SE", variable.name = "Bio.e" )
# be.er  <- left_join(n.bio, st.err, by = c("Sample", "variable"))
# be.er  <- arrange(be.er, Sample)
write_csv(n.bio, paste0(OUTPUT_PATH,"/OCR-BioEnergetics.csv"))

# write ratio based bienergetics
# # uncomment and export be.er if you want to get standard errors of bioenergetics
# st.err <- melt(log.be$standard.errors, value.name = "SE", variable.name = "variable" )
# be.er  <- left_join(l.bio, st.err, by = c("Sample", "variable"))
# be.er <- arrange(be.er, Sample)
write_csv(l.bio, paste0(OUTPUT_PATH,"/LogOCR-BioEnergetics.csv"))


```

```{r echo=FALSE}
# Print interval estimates
l.bio[1:4,] %>%
  kable(digits = 3, caption = "Example of Bioenergetics file ") %>%
  kable_styling(full_width = F)
```

# PER

## Filter out irrelevant samples

```{r echo=FALSE, message = FALSE}
# Interval 3 and 4 is not used
d_PER <- dm %>% filter(!Interval %in% c("Int3", "Int4"))

# filter out samples with any of intervals having less than 8 measurements
sumar <- d_PER %>%
  group_by(sample_id, Interval) %>%
  summarise(n = n()) %>%
  filter(n < 18)

# number of intervals has to be 2 or discarted
inter <- d_PER %>%
  group_by(sample_id) %>%
  summarise(n_inter = length(unique(Interval))) %>%
  filter(n_inter != 2)

d_PER <- d_PER %>%
  filter(! sample_id %in% unique(sumar$sample_id)) %>%
  filter(! sample_id %in% unique(inter$sample_id))

cat("Wells removed due lack of usable measurements (Less than six usable wells in any interval): ", paste(unique(sumar$sample_id), collapse = "\n"), sep = "\n")
cat("Wells removed because there are not four intervals: ", paste(unique(inter$sample_id), collapse = "\n"), sep = "\n")
```

## Remove outliers
```{r echo=FALSE, echo=FALSE}
# Identify Outliars
# DT = loaded dataframe
# cut.well = threshold for well outliaer,
# cut.point = threshold for point outliaer
# x = Variable: "LOCR" or "OCR" or "PER"

dr_per <- idfy_sinleP_outlier(DT = d_PER, cut.point = 5, x = "PER" )  # could Print arguments
# write the data into file
write_csv(dr_per, paste0(OUTPUT_PATH,"/Data_removed_PER.csv"))
```

```{r echo=FALSE, warning=FALSE, echo=FALSE}
#TO DO: convert graph to aditive add legends
#TO DO: convert graph to aditive add legends
dr_per %>%
  group_by(sample_id, is.out.p) %>%
  summarise(n = n()) %>%
  group_by(sample_id) %>%
  mutate(size = sum(n),
         ptg = n / size *100,
         percentage = paste(format(ptg, digits= 1, nsmall=2),"%")) %>%
  filter(is.out.p == T) %>%
  arrange(desc(ptg)) %>%
  select(sample_id, percentage) %>%
  kable(caption="Amount of removed outliers across samples") %>%
  kable_styling(full_width = F)

```


## Print schemes of removed points for all samples
```{r echo=FALSE}
ylim_low <- min(dr_per$PER) #write - x where x is a number to adjust the starting point of the y axis
ylim_high <- max(dr_per$PER)
for (smpl in unique(dr_per$sample_id)) {
  plot <- ggplot(filter(dr_per, sample_id == smpl), aes(Measurement, PER))+
            ggtitle(paste0("SAMPLE:  ", smpl))+
            geom_line(aes(group = Well),size = 0.2, color = "grey") +
            geom_point(aes(Measurement, PER, color = is.out.p))+
            guides(color=guide_legend(title="Outlier"))+
            xlab("Measurement")+
            ylim(ylim_low,ylim_high)+
            NULL

  print(plot +theme_bw())
}
```

## Summary statistics for each sample
```{r echo = FALSE}
per_summary_stats <- dr_per %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval, Group) %>% 
  summarise(well_mean = mean(OCR))%>% # Gives the mean value of each well withour outliers
  group_by(Group, Interval) %>% # Gives the mean value of each sample without outliers
  summarise(sample_mean = mean(well_mean),
            well_mean,
            Well)

lper_summary_stats <- dr_per %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval, Group) %>% 
  summarise(well_mean = mean(LOCR))%>% # Gives the mean value of each well withour outliers
  group_by(Group, Interval) %>% # Gives the mean value of each sample without outliers
  summarise(sample_mean = mean(well_mean),
            well_mean,
            Well)



per_summary_stats %>% ggplot(mapping = aes(x = Interval, y = well_mean, group = Group)) +
  geom_line(mapping = aes(x = Interval, y = sample_mean, group = Group), size = 0.2, color = "grey", position = position_dodge(width = 0.2) ) +
  geom_point(mapping = aes(x = Interval, y = sample_mean, fill = Group), color = "black", shape = 21, size = 3, position = position_dodge(width = 0.2) )+
  # stat_summary(fun = mean, geom = "crossbar", width = 0.1, aes(color = Group))+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.4, size = 0.5, aes(color = Group), position = position_dodge(width = 0.2) )+
  scale_fill_brewer(palette = "Dark2")+
  scale_color_brewer(palette = "Dark2")+
  ylab(expression("Mean PER value [pmol H"["+"]*" /1000 cells]"))+
  # geom_jitter(dr_ocr)
  theme_bw()+
  ggtitle("PER estimates sample summary (Outliers removed)")

lper_summary_stats %>% ggplot(mapping = aes(x = Interval, y = well_mean, group = Group)) +
  geom_line(mapping = aes(x = Interval, y = sample_mean, group = Group), size = 0.2, color = "grey", position = position_dodge(width = 0.2) ) +
  geom_point(mapping = aes(x = Interval, y = sample_mean, fill = Group), color = "black", shape = 21, size = 3, position = position_dodge(width = 0.2) )+
  # stat_summary(fun = mean, geom = "crossbar", width = 0.1, aes(color = Group))+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.4, size = 0.5, aes(color = Group), position = position_dodge(width = 0.2) )+
  scale_fill_brewer(palette = "Dark2")+
  scale_color_brewer(palette = "Dark2")+
  ylab(expression("Mean PER value [log10(pmol H"["+"]*" /1000 cells)]"))+
  # geom_jitter(dr_ocr)
  theme_bw()+
  ggtitle("LPER estimates sample summary (Outliers removed)")

```

## Bioenergetics and Estimates

```{r echo=FALSE}
norm.be.PER <- compute_bioenergetics_(dr_per, "PER")
log.be.PER  <- compute_bioenergetics_(dr_per, "LPER")

write_csv(norm.be.PER$estimates, paste0(OUTPUT_PATH,"/PER-Estimated_values.csv"))
write_csv(log.be.PER$estimates, paste0(OUTPUT_PATH,"/LPER-Estimated_values.csv"))
write_csv(norm.be.PER$bioenergetics, paste0(OUTPUT_PATH,"/PER-BE-table.csv"))
write_csv(log.be.PER$bioenergetics, paste0(OUTPUT_PATH,"/LPER-BE-table.csv"))
```
### Estimates

```{r, echo = FALSE}
# We need a different bioenergetics calculation to make the plots. The values calculated above is for each sample in each interval. We also need data for each well

per_stats <- dr_per %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval) %>%
  summarise(well_mean = mean(PER)) %>% 
  group_by(sample_id, Interval) %>%
  mutate(replicate_mean = mean(well_mean)) %>% ungroup %>%
  mutate(Date = substr(sample_id, start = nchar(sample_id)-15, stop = nchar(sample_id)),
         Group = substr(sample_id, start = 1, stop = nchar(sample_id)-19)) %>% 
  group_by(Group, Interval) %>%
  summarise(sample_mean = mean(well_mean),
            replicate_mean,
            well_mean,
            sample_id,
            Date)
  


lper_stats <- dr_per %>% filter(is.out.p == FALSE) %>% 
  group_by(sample_id, Well, Interval) %>%
  summarise(well_mean = mean(LPER)) %>% 
  group_by(sample_id, Interval) %>%
  mutate(replicate_mean = mean(well_mean)) %>% ungroup %>%
  mutate(Date = substr(sample_id, start = nchar(sample_id)-15, stop = nchar(sample_id)),
         Group = substr(sample_id, start = 1, stop = nchar(sample_id)-19)) %>% 
  group_by(Group, Interval) %>%
  summarise(sample_mean = mean(well_mean),
            replicate_mean,
            well_mean,
            sample_id,
            Date)

```



```{r, echo = FALSE, fig.width = 8 , fig.height = 8 }
per_stats %>% ggplot(aes(x=Group, y=well_mean)) + 
  geom_beeswarm(aes(color = Date), cex=2, dodge.width = 0)+
  facet_wrap(~Interval, scales = "free")+
  ylab(expression("Mean PER value [pmol H"["+"]*" /1000 cells]"))+
  xlab("Sample")+
  stat_summary(fun = mean, geom = "crossbar", width = 0.3)+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.3)+
  geom_point(aes(x=Group, y = replicate_mean, fill = Date), color = "Black", size = 4, shape = 21)+
  theme_bw()+
  theme(legend.position="bottom",     
        strip.text.x = element_text(size = 12, face = "bold"),
        strip.text.y = element_text(size = 12, face = "bold"))+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("PER estimates shown by well, replicate and sample")


lper_stats %>% ggplot(aes(x=Group, y=well_mean)) + 
  geom_beeswarm(aes(color = Date), cex=2, dodge.width = 0)+
  facet_wrap(~Interval, scales = "free")+
  ylab(expression("Mean Log(PER) value [log(pmol H"["+"]*" /1000 cells)]"))+
  xlab("Sample")+
  stat_summary(fun = mean, geom = "crossbar", width = 0.3)+
  stat_summary(fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.3)+
  geom_point(aes(x=Group, y = replicate_mean, fill = Date), color = "Black", size = 4, shape = 21)+
  theme_bw()+
  theme(legend.position="bottom",     
        strip.text.x = element_text(size = 12, face = "bold"),
        strip.text.y = element_text(size = 12, face = "bold"))+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("LPER estimates shown by well, replicate and sample")

message("Figure description: Colors indicate replicates, large points represent the group mean of wells, the bold black line is the sample mean of wells, and the errorbars shows the sd of the well means for each group")
```



### Bioenergetics

```{r message=FALSE, warning=FALSE, echo=FALSE, fig.width = 8}
# ADD coefficients of variation
# normal scale Bioenergetics

n.bio.PER <- melt(norm.be.PER$bioenergetics)
n.bio.PER <- n.bio.PER %>%  mutate(Date = substr(Sample, start = nchar(Sample)-15, stop = nchar(Sample)),
                           Group = substr(Sample, start = 1, stop = nchar(Sample)-19))

n.bio.PER %>%
  filter(variable != "Other") %>%
  ggplot(aes(variable, value, fill = variable ))+
  ggtitle("Difference based natural scale Bio-Energetics PER")+
  geom_point(aes(fill = Group, shape = Date), size = 3, position = position_dodge(width = 0.2))+
  scale_shape_manual(values= c(21,22))+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  guides(fill=guide_legend(override.aes=list(shape=21)))+
  xlab("Bio-Energetics")+
  ylab(" ")+
  theme_bw()





# log scale Bioenergetics
l.bio.PER   <- melt(log.be.PER$bioenergetics )
l.bio.PER <- l.bio.PER %>%  mutate(Date = substr(Sample, start = nchar(Sample)-15, stop = nchar(Sample)),
                           Group = substr(Sample, start = 1, stop = nchar(Sample)-19))
l.bio.PER %>%
  filter(variable != "Other") %>%
  ggplot(aes(variable, value, fill = variable ))+
  ggtitle("Difference based log scale Bio-Energetics PER")+
  geom_point(aes(fill = Group, shape = Date), size = 3, position = position_dodge(width = 0.2))+
  scale_shape_manual(values= c(21,22))+
  scale_color_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  guides(fill=guide_legend(override.aes=list(shape=21)))+
  xlab("Bio-Energetics")+
  ylab(" ")+
  theme_bw()



# add standard errors
# st.err <- melt(norm.be.PER$standard.errors, value.name = "SE", variable.name = "Bio.e" )
# be.er  <- left_join(n.bio.PER, st.err, by = c("Sample", "variable"))
# be.er  <- arrange(be.er, Sample)
write_csv(n.bio.PER, paste0(OUTPUT_PATH,"/PER-BioEnergetics.csv"))
# add standard errors
# st.err <- melt(log.be$standard.errors, value.name = "SE", variable.name = "variable" )
# be.er  <- left_join(l.bio.PER, st.err, by = c("Sample", "variable"))
# be.er <- arrange(be.er, Sample)
write_csv(l.bio.PER, paste0(OUTPUT_PATH,"/logPER-BioEnergetics.csv"))




```


# PER vs OCR

```{r echo=FALSE}
basal.OCR <- n.bio %>%
  filter(variable == "Basal.Resp") %>%
  mutate(Group = ifelse(grepl("A", Sample), "A", "B"))
basal.PER <- n.bio.PER %>%
  filter(variable == "Basal.PER") %>%
  mutate(Group = ifelse(grepl("A", Sample), "A", "B"))

total <- merge(basal.PER, basal.OCR, by = "Sample", suffixes = c(".PER", ".OCR"))

# total <- total %>%
#   mutate(Group = ifelse(grepl("B", Sample), "Post", "Pre"))

ggplot(total)+
  ggtitle("Basal.PER vs Basal.OCR")+
  geom_point(aes(value.PER, value.OCR))+
  ylab("Basal OCR")+
  xlab("Basal PER")+
  theme_bw()


```

```{r echo=FALSE}
max.OCR   <- n.bio %>% filter(variable == "Maximal.Resp") %>%
  mutate(Group = ifelse(grepl("A", Sample), "A", "B"))
max.PER <- n.bio.PER %>% filter(variable == "Max.PER") %>%
  mutate(Group = ifelse(grepl("A", Sample), "A", "B"))

total_max <- merge(max.PER, max.OCR, by = "Sample", suffixes = c(".PER", ".OCR"))

# total <- total %>%
#   mutate(Group = ifelse(grepl("B", Sample), "Post", "Pre"))

ggplot(total_max)+
  ggtitle("Max PER vs Max OCR")+
  geom_point(aes(value.PER, value.OCR))+
  ylab("Max OCR")+
  xlab("Max PER")+
  theme_bw()


```

# Stines test area. Must be deleted when pipeline is finished
<!-- # ```{r} -->
<!-- # E %>% -->
<!-- #   ggplot(aes(Interval,PER))+ -->
<!-- #   ggtitle("PER Estimates natural scale")+ -->
<!-- #   geom_boxplot( width = 0.6, outlier.size = -1, show.legend = FALSE, fill="pink", alpha = 0.7)+ -->
<!-- #   # geom_line(aes(group = sample_id, Interval,mean), col = "grey", size = .1, show.legend = FALSE)+ -->
<!-- #   geom_jitter( width = 0.2, show.legend = FALSE, size = 0.5 , alpha = 0.7)+ -->
<!-- #   xlab("Intervals")+ -->
<!-- #   ylab("logPER")+ -->
<!-- #   theme_bw() -->
<!-- # ``` -->

